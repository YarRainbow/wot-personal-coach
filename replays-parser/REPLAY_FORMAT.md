# World of Tanks Replay Format Specification

## Overview
The `.wotreplay` (and `.mtreplay` for Lesta Games) file format is a proprietary binary container used to record game sessions. 

**Is this an official standard?**
**No.** Wargaming has not released an official specification. The knowledge documented here comes from years of **reverse engineering** by the community (projects like `wotdecoder.py`, `wotreplay-parser`, and others). 
The format is essentially a serialization of the game's network traffic and internal state.

## File Structure
The file consists of **Data Blocks**. Most modern replays have 2 JSON blocks followed by a binary block.

```
[ Magic Number (4 bytes) ]  -> 0x11343212
[ Block Count  (4 bytes) ]  -> Number of JSON blocks (usually 1 or 2)
[ JSON Block 1 Size (4)  ]
[ JSON Block 1 Data ...  ]  -> "BattleConfig"
[ JSON Block 2 Size (4)  ]  -> (Optional, if Block Count >= 2)
[ JSON Block 2 Data ...  ]  -> "BattleResults"
[ Decompressed Size (4)  ]  -> Start of Binary Block
[ Compressed Size (4)    ]
[ Encrypted Data ...     ]  -> Encrypted & Compressed Game Stream
```

## The Binary Block (Gameplay Data)
The last block contains the actual gameplay. It is protected to prevent tampering.

1.  **Structure**:
    *   **Decompressed Size** (4 bytes)
    *   **Compressed Size** (4 bytes)
    *   **Encrypted Data** (Multiple of 8 bytes)

2.  **Encryption**:
    *   **Algorithm**: **Blowfish** (ECB mode).
    *   **Key**: A specific 16-byte key hardcoded in the game client (found via reverse engineering).
    *   **Chaining**: It uses a custom chaining mode where each decrypted block is XORed with the *previous* decrypted block.

3.  **Compression**:
    *   After decryption, the data is a standard **Zlib** stream.

## Packet Stream
Once decrypted and decompressed, the data is a stream of **Packets**.  
Every packet represents a network message or game event.

### Packet Header
Every packet starts with a header:
*   **Payload Length** (4 bytes): Size of the data *following* the header.
*   **Type** (4 bytes): ID of the packet (e.g., `0x0A`, `0x07`).
*   **Time** (4 bytes): Float representing time since battle start.

### Common Packet Types
These IDs were identified by analyzing game traffic and correlating it with in-game actions.

| Type (Hex) | Name | Description |
| :--- | :--- | :--- |
| `0x0A` | **Position** | Updates the position (X, Y, Z) and rotation of a vehicle. |
| `0x07` | **Entity/Health** | Updates vehicle health/state. |
| `0x05` | **Entity Creation** | A new tank/object appeared in render range. |
| `0x08` | **Tank Destruction** | A tank was destroyed. |
| `0x20` | **Chat** | Chat messages. |

## The "Black Box" (Where do these IDs come from?)
Interpreting the packet stream requires knowledge of the game client's internal definitions.

The game uses a "Definition" system:
1.  **`.def` files**: The game client contains XML files (called `.def` files) that define every entity (Tank, Gun, Map) and its properties.
2.  **Script IDs**: The replay stream just says "Entity 5, Property 3 changed to X". The game client looks up "Entity 5 is a Tank", "Property 3 is Health", so "Health = X".
3.  **Packet IDs**: The binary packet headers (like `0x0A`) are lower-level network opcodes.

### How we know them
1.  **Script Extraction**: We use `generate_ids.py` to parse the game client's XML/DEF files and extract `Account`, `Avatar`, etc. logic.
2.  **Manual Mapping**: Engine-level packet IDs (like `0x0A` for Position) are mapped in `manual_packet_defs.json` and merged into the output.

## Dynamic Parsing (The New Approach)
We use a generated metadata file: `ids_<version>.json` (e.g., `ids_wot_v1_25_1_0.json`).

### `ids_*.json` Structure
Generated by `generate_ids.py` from the game scripts + `manual_packet_defs.json`.
```json
{
  "packetTypes": {
    "0x0A": "EntityMove (Position/Rotation)",
    "0x08": "EntityMethodCall"
  },
  "entities": {
    "1": {
      "id": 1,
      "name": "Avatar",
      "clientMethods": {
        "0": { "name": "onCheckOut", "args": [] },
        "1": { "name": "update", "args": ["INT32"] }
      },
      "properties": {
        "0": { "name": "position", "type": "VECTOR3" }
      }
    }
  }
}
```

### Parsing Flow
1.  **Startup**: Parser loads `ids_<ver>.json` (or falls back to embedded defaults).
2.  **Packet 0x0A**: Look up `packetTypes["0x0A"]` -> "EntityMove".
3.  **Method Call (Packet 0x08)**:
    *   Packet payload: `[EntityID=100] [MethodID=4] ...`
    *   Entity 100 is Type 1 (Avatar).
    *   Look up `Avatar.clientMethods["4"]`.
    *   Result: `onHealthChanged(int old, int new)`.
    *   Decoder knows to read two integers.
