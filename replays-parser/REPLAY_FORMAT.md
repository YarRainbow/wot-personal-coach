# World of Tanks Replay Format Specification

## Overview
The `.wotreplay` (and `.mtreplay` for Lesta Games) file format is a proprietary binary container used to record game sessions. 

**Is this an official standard?**
**No.** Wargaming has not released an official specification. The knowledge documented here comes from years of **reverse engineering** by the community (projects like `wotdecoder.py`, `wotreplay-parser`, and others). 
The format is essentially a serialization of the game's network traffic and internal state.

## File Structure
The file consists of **Data Blocks**. Most modern replays have 2 JSON blocks followed by a binary block.

```
[ Magic Number (4 bytes) ]  -> 0x11343212
[ Block Count  (4 bytes) ]  -> Number of JSON blocks (usually 1 or 2)
[ JSON Block 1 Size (4)  ]
[ JSON Block 1 Data ...  ]  -> "BattleConfig"
[ JSON Block 2 Size (4)  ]  -> (Optional, if Block Count >= 2)
[ JSON Block 2 Data ...  ]  -> "BattleResults"
[ Decompressed Size (4)  ]  -> Start of Binary Block
[ Compressed Size (4)    ]
[ Encrypted Data ...     ]  -> Encrypted & Compressed Game Stream
```

## The Binary Block (Gameplay Data)
The last block contains the actual gameplay. It is protected to prevent tampering.

1.  **Structure**:
    *   **Decompressed Size** (4 bytes)
    *   **Compressed Size** (4 bytes)
    *   **Encrypted Data** (Multiple of 8 bytes)

2.  **Encryption**:
    *   **Algorithm**: **Blowfish** (ECB mode).
    *   **Key**: A specific 16-byte key hardcoded in the game client (found via reverse engineering).
    *   **Chaining**: It uses a custom chaining mode where each decrypted block is XORed with the *previous* decrypted block.

3.  **Compression**:
    *   After decryption, the data is a standard **Zlib** stream.

## Packet Stream
Once decrypted and decompressed, the data is a stream of **Packets**.  
Every packet represents a network message or game event.

### Packet Header
Every packet starts with a header:
*   **Payload Length** (4 bytes): Size of the data *following* the header.
*   **Type** (4 bytes): ID of the packet (e.g., `0x0A`, `0x07`).
*   **Time** (4 bytes): Float representing time since battle start.

### Common Packet Types
These IDs were identified by analyzing game traffic and correlating it with in-game actions.

| Type (Hex) | Name | Description |
| :--- | :--- | :--- |
| `0x0A` | **Position** | Updates the position (X, Y, Z) and rotation of a vehicle. |
| `0x07` | **Entity/Health** | Updates vehicle health/state. |
| `0x05` | **Entity Creation** | A new tank/object appeared in render range. |
| `0x08` | **Tank Destruction** | A tank was destroyed. |
| `0x20` | **Chat** | Chat messages. |

## The "Black Box" (Where do these IDs come from?)
Interpreting the packet stream requires knowledge of the game client's internal definitions.

The game uses a "Definition" system:
1.  **`.def` files**: The game client contains XML files (called `.def` files) that define every entity (Tank, Gun, Map) and its properties.
2.  **Script IDs**: The replay stream just says "Entity 5, Property 3 changed to X". The game client looks up "Entity 5 is a Tank", "Property 3 is Health", so "Health = X".
3.  **Packet IDs**: The binary packet headers (like `0x0A`) are lower-level network opcodes.

### How we know them
Community developers have:
1.  **Decompiled the Python scripts** inside the game client (`scripts.pkg`).
2.  **Extracted definitions** to map IDs to names.
3.  **Hardcoded** specific common IDs (like Position `0x0A`) into tools because they rarely change.

For a **robust** parser (future goal), we would need to read the `.def` files from the game folder.
For our **MVP**, we rely on the stable, hardcoded IDs found in the reference C++ project (`wotreplay-parser/src/packet.cpp`).

## How We Parse It (The Logic)
1.  **Read Header**: Verify magic number.
2.  **Read JSONs**: Parse the JSON blocks to get metadata (Map, Player).
3.  **Read Binary**:
    *   Read the encrypted buffer.
    *   **Decrypt** using the known key and Blowfish.
    *   **Decompress** using Zlib.
4.  **Iterate Packets**:
    *   Read `Length`.
    *   Read `Type`.
    *   Read `Time`.
    *   Read `Payload` (`Length` bytes).
    *   *Decode specific payload based on `Type`.*

## Dynamic Parsing (The New Approach)
Instead of hardcoding packet IDs, we now use a generated metadata file: `ids.json`.

### `ids.json` Structure
Generated by `generate_ids.py` from the game scripts.
```json
{
  "entities": {
    "1": {
      "id": 1,
      "name": "Avatar",
      "clientMethods": {
        "0": "onCheckOut",
        "1": "update"
      },
      "properties": {
        "0": "position"
      },
      "cellMethods": {},
      "baseMethods": {}
    }
  }
}
```
*   **Entities Map**: Key is the Entity Type ID (int as string).
*   **Methods/Properties**: Maps Method ID (int as string) to Method Name.

### Parsing Flow
1.  **Packet Type 0x05 (Entity Create)**: Contains `TypeID`.
2.  **Lookup**: `ids.json["entities"][TypeID]`.
3.  **Method Call (Packet 0x08/0x07??)**:
    *   If packet says "Call Method 4 on Entity 100".
    *   Entity 100 has TypeID 1 (Avatar).
    *   Look up `Avatar.clientMethods["4"]` -> "onHealthChanged".
    *   Decode payload as "onHealthChanged" arguments.
